/**
 * Core Philosophy: This ruleset implements a strict Role-Based Access Control (RBAC) model centered around a single "Administrator" role. All data-mutating operations (create, update, delete) on core business collections are restricted exclusively to authenticated users who have been designated as administrators. Public read access is granted to most collections to allow customers to browse the store.
 *
 * Data Structure: The database is organized into several flat, top-level collections:
 * - /products: Contains all product information.
 * - /categories: Contains product categories.
 * - /subcategories: Contains product subcategories.
 * - /promotion_banners: Manages promotional content.
 * - /contact_info: Stores public business contact details.
 * - /roles_admin: A special collection where the existence of a document signifies a user's admin privileges. This collection is the single source of truth for authorization.
 *
 * Key Security Decisions:
 * - Public Read, Admin Write: Most data collections are publicly readable to allow customers to view products and content, but writable only by administrators. This provides a secure posture for an e-commerce site.
 * - Centralized Role Management: The `/roles_admin` collection is used to grant admin rights. A user is an admin if a document with their UID exists in this collection. To prevent privilege escalation, this collection cannot be written to by any client; roles must be managed directly in the Firebase Console.
 * - No Data Shape Validation: In alignment with a prototyping philosophy, these rules focus strictly on authorization (who can access what) and do not validate the schema or data types of documents being written. This allows for rapid development and iteration of the data model.
 *
 * Denormalization for Authorization: The use of the `/roles_admin/{userId}` collection is a prime example of denormalization for security. Instead of checking a role field on a user profile, we use a fast `exists()` check. This avoids slow and costly `get()` calls in every rule and makes the security logic efficient and easy to reason about.
 *
 * Structural Segregation: The use of distinct top-level collections for each data type (products, categories, etc.) provides clear separation of concerns and allows for granular security policies.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user is an administrator.
     * Admin status is granted by the existence of a document in the /roles_admin
     * collection with the user's UID as the document ID. This collection
     * must be managed manually in the Firebase Console.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages access to product documents. Public can read, only admins can manage.
     * @path /products/{productId}
     * @allow (get, list) Anyone can view products.
     * @allow (create, update, delete) Only authenticated admin users can manage products.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Manages access to category documents. Public can read, only admins can manage.
     * @path /categories/{categoryId}
     * @allow (get, list) Anyone can view categories.
     * @allow (create, update, delete) Only authenticated admin users can manage categories.
     */
    match /categories/{categoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Manages access to subcategory documents. Public can read, only admins can manage.
     * @path /subcategories/{subcategoryId}
     * @allow (get, list) Anyone can view subcategories.
     * @allow (create, update, delete) Only authenticated admin users can manage subcategories.
     */
    match /subcategories/{subcategoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Manages access to promotion banners. Public can read, only admins can manage.
     * @path /promotion_banners/{bannerId}
     * @allow (get, list) Anyone can view banners.
     * @allow (create, update, delete) Only authenticated admin users can manage banners.
     */
    match /promotion_banners/{bannerId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Manages access to store contact information. Public can read, only admins can manage.
     * @path /contact_info/{contactInfoId}
     * @allow (get, list) Anyone can view contact information.
     * @allow (create, update, delete) Only authenticated admin users can manage contact info.
     */
    match /contact_info/{contactInfoId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Secures the collection that defines admin roles.
     * @path /roles_admin/{adminId}
     * @allow (get) An admin can read their own role document, but cannot list the collection.
     * @deny (list, create, update, delete) All write operations are forbidden to prevent privilege escalation from the client. Admins must be created via the Firebase Console. Listing is forbidden to prevent enumeration of administrators.
     * @principle Prevents client-side privilege escalation and admin user enumeration.
     */
    match /roles_admin/{adminId} {
      allow get: if isAdmin() && request.auth.uid == adminId;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
